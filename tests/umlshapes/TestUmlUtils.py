
from unittest import TestSuite
from unittest import main as unitTestMain

from codeallybasic.UnitTestBase import UnitTestBase

from umlshapes.UmlUtils import UmlUtils

from umlshapes.mixins.TopLeftMixin import Rectangle

from umlshapes.types.Common import AttachmentSide
from umlshapes.types.UmlPosition import UmlPosition
from umlshapes.types.UmlPosition import UmlPositions

RECTANGLE_LEFT:   int = 500
RECTANGLE_TOP:    int = 1000
RECTANGLE_RIGHT:  int = 700
RECTANGLE_BOTTOM: int = 1200

RECTANGLE_WIDTH:  int = RECTANGLE_RIGHT - RECTANGLE_LEFT
RECTANGLE_HEIGHT: int = RECTANGLE_BOTTOM - RECTANGLE_TOP

TOP_RELATIVE_POSITION_X: int = 100
TOP_RELATIVE_POSITION_Y: int = 0

RIGHT_RELATIVE_POSITION_X: int = 200
RIGHT_RELATIVE_POSITION_Y: int = 200


class TestUmlUtils(UnitTestBase):
    """
    Auto generated by the one and only:
        Gato Malo â€“ Humberto A. Sanchez II
        Generated: 01 June 2025
    """

    @classmethod
    def setUpClass(cls):
        super().setUpClass()

    def setUp(self):
        super().setUp()
        self._rectangle: Rectangle = Rectangle(
            left=RECTANGLE_LEFT,
            top=RECTANGLE_TOP,
            right=RECTANGLE_RIGHT,
            bottom=RECTANGLE_BOTTOM
        )

    def tearDown(self):
        super().tearDown()

    def testBasicDistance(self):
        pt1: UmlPosition = UmlPosition(x=2, y=3)
        pt2: UmlPosition = UmlPosition(x=5, y=7)

        expectedDistance: float = 5.0
        actualDistance:   float = UmlUtils.distance(pt1=pt1, pt2=pt2)

        self.assertAlmostEqual(expectedDistance, actualDistance, places=3, msg='Not close enough')

    def testBackwardsDistance(self):

        pt1: UmlPosition = UmlPosition(x=200, y=200)
        pt2: UmlPosition = UmlPosition(x=100, y=100)

        expectedDistance: float = 141.42
        actualDistance:   float = UmlUtils.distance(pt1=pt1, pt2=pt2)

        self.assertAlmostEqual(expectedDistance, actualDistance, places=2, msg='Not close enough')

    def testBasicClosest(self):
        umlPositions: UmlPositions = UmlPositions(
            [
                UmlPosition(100, 100), UmlPosition(100, 250), UmlPosition(100, 500), UmlPosition(100, 750), UmlPosition(100, 900),
            ]
        )
        expectedClosest: UmlPosition = UmlPosition(100, 250)
        actualClosest:   UmlPosition = UmlUtils.closestPoint(referencePosition=UmlPosition(600, 250), umlPositions=umlPositions)

        self.assertEqual(expectedClosest, actualClosest, 'Basic computation failed')

    def testClosestToGnarlyLine(self):
        umlPositions: UmlPositions = UmlPositions(
            [
                UmlPosition(147, 167), UmlPosition(232, 535), UmlPosition(410, 350), UmlPosition(833, 431)
            ]
        )

        expectedClosest: UmlPosition = UmlPosition(410, 350)
        actualClosest:   UmlPosition = UmlUtils.closestPoint(referencePosition=UmlPosition(360, 410), umlPositions=umlPositions)

        self.assertEqual(expectedClosest, actualClosest, 'Basic computation failed')

    def testNumPyClosest(self):
        umlPositions: UmlPositions = UmlPositions(
            [
                UmlPosition(26, 63), UmlPosition(25, 63), UmlPosition(24, 63),
                UmlPosition(23, 63), UmlPosition(22, 63), UmlPosition(21, 63),
                UmlPosition(20, 63), UmlPosition(22, 62), UmlPosition(27, 63)
             ]
        )
        expectedClosest: UmlPosition = UmlPosition(20, 63)
        actualClosest:   UmlPosition = UmlUtils.closestPoint(referencePosition=UmlPosition(0, 238), umlPositions=umlPositions)
        self.assertEqual(expectedClosest, actualClosest, 'Numpy computation failed')

    def testLineCentumTopFixToMin(self):
        umlPosition: UmlPosition = UmlPosition(x=RECTANGLE_LEFT + 20, y=RECTANGLE_TOP)
        distance:    float       = UmlUtils.computeLineCentum(attachmentSide=AttachmentSide.TOP, umlPosition=umlPosition, rectangle=self._rectangle)

        self.assertEqual(0.1, distance, 'Incorrect distance')

    def testCLineCentumTopFixToMax(self):
        umlPosition: UmlPosition = UmlPosition(x=self._rectangle.right, y=RECTANGLE_TOP)
        distance:    float       = UmlUtils.computeLineCentum(attachmentSide=AttachmentSide.TOP, umlPosition=umlPosition, rectangle=self._rectangle)

        self.assertEqual(0.9, distance, 'Incorrect distance')

    def testLineCentumBottomMiddle(self):
        half:        int         = (RECTANGLE_RIGHT - RECTANGLE_LEFT) // 2
        umlPosition: UmlPosition = UmlPosition(x=RECTANGLE_LEFT + half, y=RECTANGLE_BOTTOM)
        distance:    float       = UmlUtils.computeLineCentum(attachmentSide=AttachmentSide.BOTTOM, umlPosition=umlPosition, rectangle=self._rectangle)

        self.assertEqual(0.5, distance, 'Incorrect distance')

    def testLineCentumLeft(self):
        third:       int         = (RECTANGLE_BOTTOM - RECTANGLE_TOP) // 3
        umlPosition: UmlPosition = UmlPosition(x=RECTANGLE_LEFT, y=RECTANGLE_TOP + third)
        distance:    float       = UmlUtils.computeLineCentum(attachmentSide=AttachmentSide.LEFT, umlPosition=umlPosition, rectangle=self._rectangle)

        self.assertEqual(0.3, distance, 'Incorrect distance')

    def testLineCentumRight(self):
        third:       int         = (RECTANGLE_BOTTOM - RECTANGLE_TOP) // 3
        umlPosition: UmlPosition = UmlPosition(x=RECTANGLE_RIGHT, y=RECTANGLE_TOP + third * 2)
        distance:    float       = UmlUtils.computeLineCentum(attachmentSide=AttachmentSide.LEFT, umlPosition=umlPosition, rectangle=self._rectangle)

        self.assertEqual(0.7, distance, 'Incorrect distance')

    def testComputePercentageDistance(self):
        umlPosition: UmlPosition = UmlPosition(x=RECTANGLE_LEFT + 20, y=RECTANGLE_TOP)
        distance: float = UmlUtils.computeLineCentum(attachmentSide=AttachmentSide.BOTTOM, umlPosition=umlPosition, rectangle=self._rectangle)

        self.assertEqual(0.1, distance, 'Incorrect distance')

    def testAttachmentSideTop(self):
        x1: int = RECTANGLE_LEFT + 5
        y1: int = RECTANGLE_TOP
        attachmentSide: AttachmentSide = UmlUtils.attachmentSide(x=x1, y=y1, rectangle=self._rectangle)
        self.assertEqual(AttachmentSide.TOP, attachmentSide, 'Incorrect calculation')

    def testAttachmentSideBottom(self):
        x1: int = RECTANGLE_LEFT + 5
        y1: int = RECTANGLE_BOTTOM
        attachmentSide: AttachmentSide = UmlUtils.attachmentSide(x=x1, y=y1, rectangle=self._rectangle)
        self.assertEqual(AttachmentSide.BOTTOM, attachmentSide, 'Incorrect calculation')

    def testAttachmentSideLeft(self):
        x1: int = RECTANGLE_LEFT
        y1: int = RECTANGLE_BOTTOM + 6
        attachmentSide: AttachmentSide = UmlUtils.attachmentSide(x=x1, y=y1, rectangle=self._rectangle)
        self.assertEqual(AttachmentSide.LEFT, attachmentSide, 'Incorrect calculation')

    def testAttachmentSideRight(self):
        x1: int = RECTANGLE_RIGHT
        y1: int = RECTANGLE_BOTTOM + 6
        attachmentSide: AttachmentSide = UmlUtils.attachmentSide(x=x1, y=y1, rectangle=self._rectangle)
        self.assertEqual(AttachmentSide.RIGHT, attachmentSide, 'Incorrect calculation')

    def testAttachmentPointNotOnPerimeter(self):

        x: int = 22
        y: int = 44
        self.assertRaises(AssertionError, lambda: UmlUtils.attachmentSide(x, y, self._rectangle))

    def testConvertToAbsoluteCoordinatesRight(self):
        relativeCoordinates: UmlPosition = UmlPosition(x=RIGHT_RELATIVE_POSITION_X, y=RIGHT_RELATIVE_POSITION_Y)

        expectedAbsolutePosition: UmlPosition = UmlPosition(x=700, y=1200)
        absolutePosition:         UmlPosition = UmlUtils.convertToAbsoluteCoordinates(relativePosition=relativeCoordinates, rectangle=self._rectangle)

        self.assertEqual(expectedAbsolutePosition, absolutePosition, 'Incorrect right absolute coordinates')

    def testConvertToAbsoluteCoordinatesTop(self):
        relativeCoordinates: UmlPosition = UmlPosition(x=TOP_RELATIVE_POSITION_X, y=TOP_RELATIVE_POSITION_Y)

        expectedAbsolutePosition: UmlPosition = UmlPosition(x=600, y=1000)
        absolutePosition:         UmlPosition = UmlUtils.convertToAbsoluteCoordinates(relativePosition=relativeCoordinates, rectangle=self._rectangle)

        self.assertEqual(expectedAbsolutePosition, absolutePosition, 'Incorrect top absolute coordinates')

    def testConvertToRelativeCoordinateInside(self):
        x: int = 600
        y: int = 950
        #
        # This will return us an absolute position on the shape/rectangle
        absolutePosition: UmlPosition = UmlUtils.getNearestPointOnRectangle(x=x, y=y, rectangle=self._rectangle)

        expectedRelativePosition: UmlPosition = UmlPosition(x=TOP_RELATIVE_POSITION_X, y=TOP_RELATIVE_POSITION_Y)
        relativePosition:         UmlPosition = UmlUtils.convertToRelativeCoordinates(absolutePosition=absolutePosition, rectangle=self._rectangle)

        self.assertEqual(expectedRelativePosition, relativePosition, 'Incorrect relative position')

    def testConvertToRelativeCoordinateOutside(self):
        x: int = 800
        y: int = 1300

        absolutePosition:         UmlPosition = UmlUtils.getNearestPointOnRectangle(x=x, y=y, rectangle=self._rectangle)
        expectedRelativePosition: UmlPosition = UmlPosition(x=RIGHT_RELATIVE_POSITION_X, y=RIGHT_RELATIVE_POSITION_Y)
        relativePosition:         UmlPosition = UmlUtils.convertToRelativeCoordinates(absolutePosition=absolutePosition, rectangle=self._rectangle)

        self.assertEqual(expectedRelativePosition, relativePosition, 'Incorrect relative position')

    def testGetNearestPointOnRectangleTopOutside(self):
        x: int = 600
        y: int = 950

        expectedPoint: UmlPosition = UmlPosition(600, 1000)
        actualPoint:   UmlPosition = UmlUtils.getNearestPointOnRectangle(x=x, y=y, rectangle=self._rectangle)

        self.logger.debug(f'{actualPoint=}')

        self.assertEqual(expectedPoint, actualPoint, 'Calculation for top outside is wrong')

    def testGetNearestPointOnRectangleLeftOutSide(self):

        x: int = 450
        y: int = 1100

        expectedPoint: UmlPosition = UmlPosition(500, 1100)
        actualPoint:   UmlPosition = UmlUtils.getNearestPointOnRectangle(x=x, y=y, rectangle=self._rectangle)

        self.assertEqual(expectedPoint, actualPoint, 'Calculation for left outside is wrong')

    def testGetNearestPointOnRectangleRightInSide(self):

        x: int = 650
        y: int = 1100

        expectedPoint: UmlPosition = UmlPosition(700, 1100)
        actualPoint:   UmlPosition = UmlUtils.getNearestPointOnRectangle(x=x, y=y, rectangle=self._rectangle)

        self.assertEqual(expectedPoint, actualPoint, 'Calculation for left outside is wrong')

    def testIsVerticalSideTop(self):
        self.assertFalse(UmlUtils.isVerticalSide(AttachmentSide.TOP))

    def testIsVerticalSideBottom(self):
        self.assertFalse(UmlUtils.isVerticalSide(AttachmentSide.BOTTOM))

    def testIsVerticalSideRight(self):
        self.assertTrue(UmlUtils.isVerticalSide(AttachmentSide.RIGHT))

    def testIsVerticalSideLeft(self):
        self.assertTrue(UmlUtils.isVerticalSide(AttachmentSide.LEFT))


def suite() -> TestSuite:
    import unittest

    testSuite: TestSuite = TestSuite()

    testSuite.addTest(unittest.defaultTestLoader.loadTestsFromTestCase(testCaseClass=TestUmlUtils))

    return testSuite


if __name__ == '__main__':
    unitTestMain()
